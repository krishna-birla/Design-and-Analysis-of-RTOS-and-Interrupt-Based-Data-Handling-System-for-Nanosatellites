Title:
Design and analysis of RTOS and interrupt based data handling system for nanosatellites

Abstract:
In this paper, we describe the design and working of the data handling system of a Nanosatellite that houses three interconnected microcontrollers, each present on a different PCB. The three microcontrollers used are namely: STM32F207IG, MSP430F5438A and STM32L431CC. A brief description of the evolution of the system organisation and the motivation behind the choice of the microcontrollers has been provided. Each microcontroller handles and performs a set of tasks to ensure smooth and proper functioning of the satellite. An in-depth explanation of these tasks and their distribution among the three microcontrollers has been provided. The STM32F207IG microcontroller is present on the primary PCB and is responsible for interfacing with different on-board sensors and the thermal camera, for running the attitude determination and control and the power management algorithms and for processing and transmitting the payload data. The MSP430F5438A is present on the secondary PCB and performs the task of controlling all mechanisms of the satellite which includes the antenna, door and tether deployment, the collection of health data of the satellite from the other two microcontrollers, the transmission of beacon data and receiving any up-links from the ground station. The functioning of the reaction wheels present on the satellite is handled by the STM32L431CC microcontroller. The scheduling of tasks on STM32F2 and MSP430 is brought about through the use of a Real-Time Operating System (RTOS), Micrium OS-III, which allows the system to be sensitive to the priorities and time constraints of each task. An in-depth qualitative analysis of the application of the RTOS has been presented along with a vigorous quantitative analysis through the use of Segger SystemView for STM32F2 and the Sampled Graph feature in IAR for MSP430. In contrast to the implementation of an RTOS on STM32F2 and MSP430, the STM32L4 is run and controlled purely through interrupts from STM32F2 and MSP430. The paper provides an explanation for the use of a partial OS based and partial interrupt based task switching model and lists out the advantages and limitations of the same. The paper also describes the various stages involved in the onboard processing of images obtained from the thermal camera, which includes image tiling, image compression and data encoding algorithms before transmitting. The encoding algorithms help in reducing data loss during transmission and allow error detection and correction upon reception of the payload data.

Introduction:

Performance Comparison Of OS-based and Interrupt-based Systems:
The system organisation revolves around OS based and interrupt based task scheduling. The STM32F2 and MSP430 implement task scheduling with the help of an RTOS whereas the STM32L4 uses interrupt based task management. The tasks on STM32F2 and MSP430 are long lasting and hence can starve other tasks in the absense of an OS. They have strict deadlines and ordering issues

STM32L4 Operations:
The STM32L431CC microcontroller resides on the tertiary PCB with other components includng motor drivers and current-sense devices. It is connected to the other two microcontrollers via different I2C buses hence completeing the virtual linear connection between the three microcontrollers. STM32L4 acts as the slave for both its I2C buses and forms a delayed virtual connection by simulating a multi-master environment. This provides the functionalities of such an environment while still avoiding the complexities of one at the cost of processing time required for the simulation. This trade-off between processing time and environment complexity is compensated for by using static, non-parameterized and fixed size I2C buffers, making the algorithm not a function of any incoming data, thus improving the overall complexity. Upon receiving data into the I2C buffer, STM32L4 truncates and concatenates some bytes to it and copies its modified contents into the other I2C buffer, making it ready for sending on its I2C bus. The incoming data from STM32F2 contains actuation information and housekeeping data to be acted upon and passed to the MSP430 for transmission. The incoming data from MSP430 contains its housekeeping information and opcodes from the ground station to be passed on to the STM32F2. STM32L4 processes its incoming I2C buffers before copying it into the outgoing I2C buffers by truncating the actuation information and concatenating its own housekeeping data which includes rotor lock flags, OCPC status flags and feedback value of motor drivers. The actuation information contains required RPM values to be applied on the motor drivers for spacial stablization of the system which are then converted into PWM ratios and respective PWM signals are generated on the GPIO pins. In an event of rotor lock, the STM32F2 is informed about the rotor lock condition for it to switch to a predefined failure model while STM32L4 continues to apply its error detection and correction techniques on the motor drivers to achieve a better rotor lock state. Since the rotor lock values are updated multiple times between two consecutive Attitude Determination and Control (ADCS) cycles, the values are guaranteed to be well within the accepted margin of error. The priority of the I2C bus connecting STM32L4 and STM32F2 is greater than the one connecting STM32L4 and MSP430 which ensures uninterrupted transactions on the former at the cost of starvation of the later. However, the solution to the starvation problem is intrinsic to the system. The ADCS cycle has a frequency of approximately 2Hz while I2C runs at 100kHz on an 80 MHz clock on STM32L4 which brings the probability of a starvation to occur down to approximately 0.00002, low enough to be excluded from the error handling algorithm. However, a naive re-transmission strategy has been implemented on MSP430 to go about the starvation problem in the worst case scenario. Apart from its primary task of establishing the virtual linear connection as a mediator, the STM32L4 also records feedback values from the motor drivers and runs a psuedo watchdog to ensure fluent operation. The feedback from the motor drivers is a pulse with its frequency linearly mapped to a particular range of RPM values of the motor depending on the hardware configuration of the motor. 

The primary task of STM32L4 is to efficiently and timely operate the virtual connection between the two other microcontrollers by passing data in either direction and control the actuaters based on the received data when it is not part of an active communication. Since the packet format for this virtual bus is predefined, the I2C buffers on L4 are static in nature and the processing after every transaction is constant. This allows prediction of processing time and type which reduces the call for redundencies and error control. Once the control data is received, the motor drivers are checked for correct functioning and if everything is fine, the data is transfered to the motor structure and PWM is applied. The motor feedback is taken periodically and concatenated to the I2C buffer to report to the primary. Based on these feedback values, a different breaking logic may be applied to achieve required speed in the shortest amount of time. If all systems are not running properly, the microcontroller tries to detect and debug the problem using several error handling techniques. A psuedo watch dog has been implemented on an independent clock to implement some of these methods. In the extreme case, the microcontroller performs a system reset and calls the cortex startup code. To prevent the system from resetting, different modes have designed for different types of failures for the system to rum into before performing the system reset until a system reset is inevitable.

Lessons Learnt:

Justification Of A No-OS Model On STM32L4:
The STM32L4 microcontroller runs on 

Future Propects:

History:

Evoluiton:

