Title:
Design and analysis of RTOS and interrupt based data handling system for nanosatellites

Abstract:
In this paper, we describe the design and working of the data handling system of a Nanosatellite that houses three interconnected microcontrollers, each present on a different PCB. Each microcontroller handles and performs a set of tasks to ensure smooth and proper functioning of the satellite. A brief description of the evolution of the system organization and the motivation behind the choice of the microcontrollers has been provided. An in-depth explanation of the tasks and their distribution among the three microcontrollers follows. The scheduling of tasks on two of the microcontrollers is brought about through the use of a Real-Time Operating System (RTOS), Micrium OS-III, which allows the system to be sensitive to the priorities and time constraints of each task. An in-depth qualitative analysis of the application of the RTOS has been presented along with a vigorous quantitative analysis through the use of Segger SystemView and the Sampled Graph feature in IAR. In contrast to this OS based implementation, the third microcontroller is run and controlled purely through interrupts from the other two processors. The paper provides an explanation for the use of a partial OS based and partial interrupt based task switching model and lists out the advantages and limitations of the same. The paper also describes the various stages involved in the onboard processing of images obtained from the thermal camera, which includes image compression and data encoding algorithms before transmitting that help in reducing data loss during transmission and allow error detection and correction upon reception of the payload data.

Performance Comparison Of OS-based and Interrupt-based Systems:
The system organisation revolves around OS based and interrupt based task scheduling, where the STM32F2 and MSP430 implement task scheduling with the help of a real time operating system (RTOS) and the STM32L4 uses interrupt based task management. The choice of architecture cannot be made by a simplistic differntiation between the two models and needs to take into account the nature of tasks, the workload and the available processing power. The tasks on the STM32F2 and MSP430 are multiplexable in time, long-lived, interruptable and secure from the hazards of parallel processing. These tasks are an ordered set of sub-tasks, with their time of execution being of no significance at all, making bigger and bigger chuncks of code intrinsicly non-atomic in nature. The sub-tasks or sub-sub-tasks of these tasks might require an atomic fashion of execution to produce correct results, for example writing a byte of data into the flash, but together they constitute to create tasks which can be highly multiplexed in time and space, for example writing an image into the flash. Most of these tasks are executed due to triggers caused by specific flags which means they can be absent from the active set of tasks for a long time. Sudden introduction of these tasks into the ready list, for example transmission of image when over the region of interest, can cause errors in execution of other housekeeping tasks and requires robust task switching to continue normal operation by providing the illusion of CPU time to all the tasks equally. Since this is a dynamic system, the data is always actively changing and the results of various functions are only true for small periods of time, requiring frequent updates to maintain the integrity of data, irrespective of the previous state of those functions. Such functions are called real time tasks, with strict deadlines and an ignorance to the process of generating data if it cannot be done in the specified amount of time. The function needs to move on, in order to make a new attempt to generate reliable data instead of waiting for some data that was to be generated by a previous stuck state of the function, for example a failed I2C communication. This is exactly what makes a real time operating system (RTOS) a necessity in real time distributed systems. On the other hand, the tasks on STM32L4 are non-multiplexable in time, short-lived, non-interruptable and prone to the hazards of parallel processing. STM32L4 receives preprocessed data ready for application which usually means initiating an I2C communication on the virtual linear bus or probing the incoming frequency from the motor drivers for a few consecutive pulses. These tasks are composed of less number of subtasks which are not interleavable in space and time, making the whole task intrinsicly atomic in nature, for example capturing and comparing input pulses which requires consecutive pulses to be captured with no time delay. Moreover, there are a less number of tasks on the STM32L4 as compared to the other two microcontrollers and the memory overhead generated by using an operating system model is huge. Since the STM32L4 processor is a mediator between its two masters and uses data generated by them, it works just fine on the HAL kernal without implementing any layer of operating system above it. In conclusion, the use of an operating system seems unavoidable in cases where a large number of multiplexable real time tasks are run on a single master processor, but can be avoided in cases where a small number of short-lived tasks are running on a single slave processor, taking into consideration the discussed architecture.

STM32L4 Operations:
The STM32L431CC microcontroller running at 80MHz resides on the tertiary PCB with other components including motor drivers, GPIO extender and current-sense devices. It directly runs on the HAL kernal without any operating system layered between them which makes it an interrupt based system. It is connected to the other two microcontrollers via different I2C buses hence completing the virtual linear connection between the three microcontrollers. STM32L4 acts as the slave for both its I2C buses and forms a delayed virtual connection by simulating a multi-master environment. This provides the functionalities of such an environment while still avoiding the complexities of one at the cost of processing time required for the simulation. This trade-off between processing time and environment complexity is compensated for by using static, non-parameterized and fixed size I2C buffers, making the algorithm not a function of any incoming data, thus improving the overall complexity. Upon receiving data into the I2C buffer, STM32L4 truncates and concatenates some bytes to it and copies its modified contents into the other I2C buffer, making it ready for sending on its I2C bus. The incoming data from STM32F2 contains actuation information and housekeeping data to be acted upon and passed to the MSP430 for transmission. The incoming data from MSP430 contains its housekeeping information and opcodes from the ground station to be passed on to the STM32F2. STM32L4 processes its incoming I2C buffers before copying it into the outgoing I2C buffers by truncating the actuation information and concatenating its own housekeeping data which includes rotor lock flags, OCPC status flags and feedback value of motor drivers. The actuation information contains required RPM values to be applied on the motor drivers for spacial stabilization of the system which are then converted into PWM ratios and respective PWM signals are generated on the GPIO pins. In an event of rotor lock, the STM32F2 is informed about the rotor lock condition for it to switch to a predefined failure model while STM32L4 continues to apply its error detection and correction techniques on the motor drivers to achieve a better rotor lock state. Since the rotor lock values are updated multiple times between two consecutive Attitude Determination and Control (ADCS) cycles, the values are guaranteed to be well within the accepted margin of error. The priority of the I2C bus connecting STM32L4 and STM32F2 is greater than the one connecting STM32L4 and MSP430 which ensures uninterrupted transactions on the former at the cost of starvation of the later. However, the solution to the starvation problem is intrinsic to the system. The ADCS cycle has a frequency of approximately 0.5Hz while I2C runs at 100kHz on an 80MHz clock on STM32L4 which brings the probability of a starvation to occur down to approximately 0.00002, low enough to be excluded from the error handling algorithm. However, a naive re-transmission strategy has been implemented on MSP430 to go about the starvation problem in the worst case scenario. Apart from its primary task of establishing the virtual linear connection as a mediator, the STM32L4 also records feedback values from the motor drivers and runs a psuedo watchdog to ensure fluent operation. The feedback from the motor drivers is a pulse with its frequency linearly mapped to a particular range of RPM values of the motor depending on the initial hardware configuration of the motor. Three timers have been dedicated for capturing the input pulse from their respective motor drivers in HAL's input compare mode whenever a request is generated for the same. The interrupt service routine (ISR) of these timers have been assigned the highest priority among all active ISRs due to the non-interruptable and short-lived nature of these tasks. The clock for input compare has been prescaled to 80kHz with a count up value of 0xFFFF whereas the feedback frequencies are in the range 15Hz to 180Hz, allowing complete encapsulation of the measurable range of RPM values that will ever be achieved by the system by the respective probing input compare timers. In case of an anomaly in the feedback values, the rotors are checked for rotor lock condition and the motor driver OCPCs are checked for a fault condition which if detected, is informed about to the STM32F2 for invoking the required failure mode. The psuedo watch runs a timer on an independent low frequency clock at approximately the same frequency as the ADCS cycle which monitors a watchdog variable for predicting the current state of the system. Based on the modules which are up and running, the watchdog activates and deactivates various error handling codes which in the extreme of cases can result in a full system reset. The watchdog resets and reactivates its timer if no error is detected and the microcontroller resumes ideal operation. However, in cases when an error is detected, the watchdog classifies the error either as a predefined and modeled failure or a failure due to asynchronization in hardware and software. Based on this classification, the error is either reported to STM32F2 for it to switch to a failure mode or an error correction attempt is made by resetting and reinitialising various modules to re-establish a synchronized state of the system until a full system reset is inevitable which means calling the cortex startup code all over again.

STM32F2 operations:
The STM32F207IG microcontroller running at 168MHz resides on the primary PCB with other components including ADCS sensors, transceiver, flash and SRAM. It runs on a real time operating system (RTOS) named Micrium OS-III where every function has been implemented as a real time task, making it a real time distributed system. The STM32F2 carries most of the load of the satellite since it runs the ADCS algorithm and interfaces with multiple devices on-board which run on different communication protocols. It is connected directly to the STM32L4 on the tertiary PCB via an I2C bus for which it acts as the master and indirectly connected to the MSP430 on the secondary PCB via the virtual linear connection established by STM32L4. Other connections include the thermal imaging camera via UART and DCMI, the GPS via UART, the transceiver and ADCS sensors via I2C, the Flash via SPI and the SRAM via FSMC. The primary task of STM32F2 is to execute the Attitude Determination and Control (ADCS) cycle which runs at a frequency of approximately 0.5Hz and contains a number of predefined tasks in the form of a multilevel tree branched in both space and time. This allows parallel execution of independent tasks and supports preemption of most tasks which are not time dependent or are long-lived and interruptable. The functions which are short lived and non-interruptable and cannot be multiplexed in time are prefixed with scheduler lock statements to ensure their streamlined execution. The ADCS cycle starts with recording orbital parameters and gyration values to locate the satellite in the assumed euclidean space and to calculate the degree of deviation from the desired attitude of the satellite which requires interfacing with the sensors done on a seperate I2C bus. This aquired data is then fed into the actuation algorithm which converts this euclidean vector into a hamiltonian vector, a process known as quaternionic representation which allows spacial rotation of the satellite in all three dimensions. The resultant vector is converted into actuation data, which holds the information about actual PWM values to be generated on the actuators which in turn can produce the required amount of torque to ultimately bring the system within the accpeted margin of stablization error. Among the two sets of actuators present on board, the magnetorquers and reaction wheels, the choice of actuator depends on various physical factors such as power budget, error margin and region of application. The magnetorquers are directly controlled by the STM32F2 using dedicated timers for generating PWM signals on the GPIO pins whereas the reaction wheels are controlled by the STM32L4 to which the actuation data is sent over the I2C bus for application. Apart from the line of tasks including actuation and stablization, other lines of tasks on STM32F2 include capturing, processing and transmitting payload data, calliberating the orbit propogator, monitoring and optimizing battery use and generating housekeeping data. STM32F2 interfaces to the thermal camera using the UART protocol to issue click commands and configure data rate but uses DCMI to extract the raw data directly in the form of 14-bit wide pixels. The images are clicked at 30fps and stored in the SRAM using FSMC interface with a maximum of three images at a time which are read for processing and transmission and then replaced with a new set of images. The images are 2-D arrays 512 pixels high and 640 pixels wide, which are read from the SRAM as tiles of 16 x 16 pixels and fed into the lossless compression algorithm. The output of the compression algorithm is a set of 1280 compressed packets obtained from one image which are further processed to handle fragmentation loss and transmission loss by concatenating them to prefixes containing index and length, which finally are stored into the flash in contiguous memory locations with the timestamp specific to every image. When the satellite is over the region of interest and the power budget allows transmission of data, the compressed and processed data is fetched in chunks of 223 bytes and fed into the RS encoding algorithm which spits out a stream of 255 bytes ready for transmission. These byte streams are then handed over to the CC1101 transceiver in pairs which implements packetization as a part of its own transmission protocol and ultimately transmits those packets to be intercepted by the ground station. A reverse engineered algorithm is used to retrieve the original images and further image processing is used to enhance and extract as much information as possible out of them. The orbit propogator is a tool which uses orbital dynamics to predict the location of the stellite in the assumed euclidean space at time t based on the orbital parameters at time t - 1 (t minus one). Like any dynamic system, the orbit propogator accumulates error due to unquantifiable variables and needs calliberation, which is provided by interfacing with the on-board GPS using the UART communication protocol and hence the values of orbit propogator are correctly updated. The satellite's orbit is geocentric which results in periodic eclipses on the satellite making it unable to generate power using its solar panels. Hence, the satellite needs to store the extra power generated and ration its power consumption. This requires strict monitoring and optimization of power use and the battery is under constant inspection by the microcontroller. Various power modes have been designed to cater to the satellite's power needs which enable or disable some hardware and software modules and save power for the essential modules of the system to ensure proper functioning. The opcodes received in every inter-PCB I2C transaction are acted upon follwed by sending the STM32F2 housekeeping data in the departing I2C transaction on the bus.

MSP430 Operations:
The MSP430F5438A microcontroller running at 32MHz resides on the secondary PCB with other components including EEPROM, transceiver, watchdog and current-sense devices. It runs on a real time operating system (RTOS) named Micrium OS-III where every function has been implemented as a real time task, making it a real time distributed system. The MSP430 interfaces with several peripherals and handles mechanisms and beacon transactions with the ground station, making it the entry point for any ground to satellite communication. It is connected directly to the STM32L4 on the tertiary PCB via an I2C bus for which it acts as the master and indirectly connected to the STM32F2 on the primary PCB via the virtual linear connection established by STM32L4. Other connections include the EEPROM via SPI and the current-sense unit and the transceiver via I2C. The primary goal of MSP430 is to establish a persisting connection with the ground station at all times and act as a stand alone communications hub for the mission even in the worst case scenario where the other two processors fail to deliver. The housekeeping data collected from all probing devices and the feedback value generated by the actuators travels on the virtual linear I2C bus and arrives at MSP430 for final stage of processing followed by transmission. MSP430 adds its own housekeeping data to the byte stream and feeds it into a morse code generator to be transmitted once the satellite is within the ground station's acceptance cone. The time in every orbit of the satellite which overlaps with this acceptance cone is multiplexed to handle transmission and reception psuedo paralelly by dividing the morse data into four segments that are transmitted at intervals of 60 seconds, during which the satellite accepts opcodes from the ground station. Without the loss of generality, the ADCS cycle continues to accept these opcodes and generate more data to be transmitted back by MSP430 in the upcoming window. The mechanism tasks which include antenna deployment, door deployment and tether deployment are carried out by MSP430 as a series of predefined events in time and are error handled by various software and hardware means. Each one-time executable task has a flag associated with it which is saved by the alterations caused due to a full system reset with the use of an EEPROM. The MSP430 houses an independent watchdog that initiates a full system reset if the peripherals are non-responsive and interrupts are not being generated in the way expected. The EEPROM makes sure that the system resumes from the last dynamic cycle and does not perform any one-time executable task again after resetting by loading the last state of the system in the EEPROM in every cycle. Towards the end of the mission, the satellite decomissions upon receiving the opcode for it or completing the mission life, which ever is earlier and stops all communication whatsoever marking the end of the operational part of the mission.

Error Handling:
All real time distributed systems are prone to hardware and software errors, requiring a robust and dynamic error handling algorithm which should itself be recursively safe from the errors it is trying to solve while still being a part of the same system. Although the problem sounds paradoxical, some hardware and software changes can solve the problem to a great extent and bring down the probability of an unsolvable error occuring to a minimum. Independent watchdogs are great examples of such hardware changes which solve the problem of error detection and to some extent, error correction. In an event of the system hanging due to bad scheduling, asynchronization between hardware and software, hardware lock or power failure, the watchdog serves as a great tool to detect the error in its prelimnary stage and make a first naive attempt to correct it. Complementing the watchdog with a permanent storage device such as an EEPROM helps in transforming this naive attempt into a dynamic algorithm which allows the system to not only reset by hit and trial but to record and analyse the conditions which triggered the reset in the first place. The system can then disable or re-initialize individual modules that caused the error and update all processors with this information to re-establish synchronization by invoking a predefined algorithm for a modeled failure in all the processors. A multi-processor environment reduces the chances of a complete system breakdown and provides a window for redundancies which different parts of the satellite to act as stand alone modules. A dominant I2C architechture where two processors are the master of the same processor further reduces the chances of error as compared to a transitive I2C architecture where a processor is a master for one but the slave for another processor by reducing the number of possible link failure points. Apart from the hardware implementations, some algorithmic changes can further enhance the system's error deteciton and correction capability. Backtracking is one such method, to start detecting the error from the layers farthest from the hardware layer and move down in the heirarchy by one step at a time. This is implemented by reading predefined bytes from the peripherals, called the peripheral ID, to ensure the absense of an error at that layer. The next layer involves re-initializing the underlying structures used for communication and configuration of the peripheral causing the error and invoking a different configuration if necessary. The next layer involves the communication protocol being used by the peripheral and to re-configure the registers used by the protocol in order to re-establish connection followed by the last layer, which involves the hardware and requires a hard reset of the peripheral. Other more naive algorithms include hit and trial strategies used for those modules only which are less prone to errors and are guaranteed to revive at some point in time. An OS based error handling is intrinsic to the scheduling algorithm implemented by the OS itself which prevents the system from freezing in a particular state and continues system operation until that error is detected and corrected.

Lessons Learnt:


Justification Of A No-OS Model On STM32L4:
The tasks on the STM32L4 have been scheduled using interrupts from the other two processors, in contrast to the other two processors which use a real time operating system (RTOS) to schedule their tasks. This choice is made based on the available processing power, the availibility of a code library and the nature of the tasks to be executed itself. The tasks on STM32L4 are short-lived, time dependent and cannot be interrupted by other tasks in order for them to produce the expected results. Tasks on STM32L4 include I2C communication, buffer processing, input frequency compare and GPIO probing, all of which contain sub-tasks to be executed in a strict order and at specific intervals of time. Interleaving of these sub-tasks among different tasks will result in catastrophic failure and produce error conditions like asynchronization of hardware and software resulting in a useless system reset. However, if an OS based model is forced upon this pool of tasks, the code will ultimately end up using scheduler lock statements before every function, hence defeating the purpose of using the OS in the first place. The second functionality provided by an OS is a precise channel of timers that can run independently from the scheduler and can be used for error handling parallel to the task switching. Since the STM32L4 has multiple independent clock sources with available slots, specific timers can be dedicated for running error handling algorithms and psuedo watchdogs without interrupting the mainline tasks, hence fulfilling the need of OS timers. Operating systems require huge stacks of memory and a fair share of CPU cycles to execute system calls and scheduling algorithms which consumes memory and power that can be conserved by using an interrupt based model. The HAL kernal is sufficient enough in providing the required functionalities to cater to the needs of this processor, especially when considering the fact that STM32L4 is a slave to other processors and does not generate any data but only uses that it is provided with. The whole point of a modularized multi-processor environment is to decrease the system complexity, therefore further decreasing the possibilities of an error which is simply acheived by implementing an interrupt based model on the STM32L4 and reducing one redundant layer between the kernal and the code.

Future Propects:

History:

Evoluiton:

