Title:
Design and analysis of RTOS and interrupt based data handling system for nanosatellites

Abstract:
In this paper, we describe the design and working of the data handling system of a Nanosatellite that houses three interconnected microcontrollers, each present on a different PCB. The three microcontrollers used are namely: STM32F207IG, MSP430F5438A and STM32L431CC. A brief description of the evolution of the system organisation and the motivation behind the choice of the microcontrollers has been provided. Each microcontroller handles and performs a set of tasks to ensure smooth and proper functioning of the satellite. An in-depth explanation of these tasks and their distribution among the three microcontrollers has been provided. The STM32F207IG microcontroller is present on the primary PCB and is responsible for interfacing with different on-board sensors and the thermal camera, for running the attitude determination and control and the power management algorithms and for processing and transmitting the payload data. The MSP430F5438A is present on the secondary PCB and performs the task of controlling all mechanisms of the satellite which includes the antenna, door and tether deployment, the collection of health data of the satellite from the other two microcontrollers, the transmission of beacon data and receiving any up-links from the ground station. The functioning of the reaction wheels present on the satellite is handled by the STM32L431CC microcontroller. The scheduling of tasks on STM32F2 and MSP430 is brought about through the use of a Real-Time Operating System (RTOS), Micrium OS-III, which allows the system to be sensitive to the priorities and time constraints of each task. An in-depth qualitative analysis of the application of the RTOS has been presented along with a vigorous quantitative analysis through the use of Segger SystemView for STM32F2 and the Sampled Graph feature in IAR for MSP430. In contrast to the implementation of an RTOS on STM32F2 and MSP430, the STM32L4 is run and controlled purely through interrupts from STM32F2 and MSP430. The paper provides an explanation for the use of a partial OS based and partial interrupt based task switching model and lists out the advantages and limitations of the same. The paper also describes the various stages involved in the onboard processing of images obtained from the thermal camera, which includes image tiling, image compression and data encoding algorithms before transmitting. The encoding algorithms help in reducing data loss during transmission and allow error detection and correction upon reception of the payload data.

Introduction:

Performance Comparison Of OS-based and Interrupt-based Systems:
The system organisation revolves around OS based and interrupt based task scheduling. The STM32F2 and MSP430 implement task scheduling with the help of an RTOS whereas the STM32L4 uses interrupt based task management. The tasks on STM32F2 and MSP430 are long lasting and hence can starve other tasks in the absense of an OS. They have strict deadlines and ordering issues

STM32L4 Operations:
The STM32L431CC microcontroller running at 80MHz resides on the tertiary PCB with other components includng motor drivers, GPIO extender and current-sense devices. It directly runs on the HAL kernal without any operating system layered between them which makes it an interrupt based system. It is connected to the other two microcontrollers via different I2C buses hence completeing the virtual linear connection between the three microcontrollers. STM32L4 acts as the slave for both its I2C buses and forms a delayed virtual connection by simulating a multi-master environment. This provides the functionalities of such an environment while still avoiding the complexities of one at the cost of processing time required for the simulation. This trade-off between processing time and environment complexity is compensated for by using static, non-parameterized and fixed size I2C buffers, making the algorithm not a function of any incoming data, thus improving the overall complexity. Upon receiving data into the I2C buffer, STM32L4 truncates and concatenates some bytes to it and copies its modified contents into the other I2C buffer, making it ready for sending on its I2C bus. The incoming data from STM32F2 contains actuation information and housekeeping data to be acted upon and passed to the MSP430 for transmission. The incoming data from MSP430 contains its housekeeping information and opcodes from the ground station to be passed on to the STM32F2. STM32L4 processes its incoming I2C buffers before copying it into the outgoing I2C buffers by truncating the actuation information and concatenating its own housekeeping data which includes rotor lock flags, OCPC status flags and feedback value of motor drivers. The actuation information contains required RPM values to be applied on the motor drivers for spacial stablization of the system which are then converted into PWM ratios and respective PWM signals are generated on the GPIO pins. In an event of rotor lock, the STM32F2 is informed about the rotor lock condition for it to switch to a predefined failure model while STM32L4 continues to apply its error detection and correction techniques on the motor drivers to achieve a better rotor lock state. Since the rotor lock values are updated multiple times between two consecutive Attitude Determination and Control (ADCS) cycles, the values are guaranteed to be well within the accepted margin of error. The priority of the I2C bus connecting STM32L4 and STM32F2 is greater than the one connecting STM32L4 and MSP430 which ensures uninterrupted transactions on the former at the cost of starvation of the later. However, the solution to the starvation problem is intrinsic to the system. The ADCS cycle has a frequency of approximately 0.5Hz while I2C runs at 100kHz on an 80MHz clock on STM32L4 which brings the probability of a starvation to occur down to approximately 0.00002, low enough to be excluded from the error handling algorithm. However, a naive re-transmission strategy has been implemented on MSP430 to go about the starvation problem in the worst case scenario. Apart from its primary task of establishing the virtual linear connection as a mediator, the STM32L4 also records feedback values from the motor drivers and runs a psuedo watchdog to ensure fluent operation. The feedback from the motor drivers is a pulse with its frequency linearly mapped to a particular range of RPM values of the motor depending on the initial hardware configuration of the motor. Three timers have been dedicated to capture the input pulse from their respective motor drivers in HAL's input compare mode whenever a request is generated for the same. The interrupt service routine (ISR) of these timers have been assigned the highest priority among all active ISRs due to the non-interruptable and short lived nature of these tasks. The clock for input compare has been prescaled to 80kHz with a count up value of 0xFFFF where as the feedback frequencies are in the range 15Hz to 180Hz, allowing complete encapsulation of the measureable range of RPM values that will ever be achieved by the system by the respective probing input compare timers. In case of an anomaly in the feedback values, the rotors are checked for rotor lock condition and the motor driver OCPCs are chcked for a fault condition which if detected, is informed about to the STM32F2 for invoking the required failure mode. The psuedo watch runs a timer on an independent low frequency clock at approximately the same frequency as the ADCS cycle which monitors a watchdog variable for predicting the current state of the system. Based on the modules which are up and running, the watchdog activates and deactivates various error handling codes which in the extreme of cases can result in full system reset. The watchdog resets and reactivates its timer if no error is detected and the microcontroller resumes ideal operation. However, in cases when an error is detected, the watchdog classifies the error either as a predefined and modeled failure or a failure due to asynchronization in hardware and software. Based on this classification, the error is either reported to STM32F2 for it to switch to a failure mode or an error correction attempt is made by resetting and reinitialising various modules to re-establish a synchronized state of the system until a full system reset is inevitable which means calling the cortex startup code all over again.

STM32F2 operations:
The STM32F207IG microcontroller running at 168MHz resides on the primary PCB with other components including ADCS sensors, transceiver, flash and SRAM. It runs on a real time operating system (RTOS) named Micrium OS-III which makes it a real time distributed system. The STM32F2 carries most of the load of the satellite since it runs the ADCS algorithm and interfaces with multiple devices on-board which run on different communication protocols. It is connected directly to the STM32L4 on the tertiary PCB via an I2C bus for which it acts as the master and indirectly connected to the MSP430 on the secondary PCB via the virtual linear connection established by STM32L4. Other connections include the thermal imaging camera via UART and DCMI, the GPS via UART, the transceiver and ADCS sensors via I2C, the Flash via SPI and the SRAM via FSMC. The primary task of STM32F2 is to execute the Attitude Determination and Control (ADCS) cycle which runs at a frequency of approximately 0.5Hz and contains a number of predefined tasks in the form of a multilevel tree branched in both space and time. This allows parallel execution of independent tasks and supports preemption of most tasks which are not time dependent or are long lived and interruptable. The ADCS cycle starts with recording orbital parameters and gyration values to locate the satellite in the assumed euclidean space and to calculate the degree of deviation from the desired attitude of the satellite which requires interfacing with the sensors done on a seperate I2C bus. This aquired data is then fed into the actuation algorithm which converts this euclidean vector into a hamiltonian vector, a process known as quaternionic representation which allows spacial rotation of the satellite in all three dimensions. The resultant vector is converted into actuation data, which holds the information about actual PWM values to be generated on the actuators which in turn can produce the required amount of torque to ultimately bring the system within the required margin of stablization error. Among the two sets of actuators present on board, the magnetorquers and reaction wheels, the choice of actuator depends on various physical factors such as power budget, error margin and region of application. The magnetorquers are directly controlled by the STM32F2 using dedicated timers for generating PWM signals on the GPIO pins whereas the reaction wheels are controlled by the STM32L4 to which the actuation data is sent over the I2C bus for application. Apart from the line of tasks including actuation and stablization, other lines of tasks on STM32F2 include capturing, processing and transmitting payload data, calliberating the orbit propogator, monitoring and optimizing battery use and generating housekeeping data. STM32F2 interfaces to the thermal camera using the UART protocol to issue click commands and configure data rate but uses DCMI to extract the raw data directly in the form of 14-bit wide pixels. The images are clicked at 30fps and stored in the SRAM using FSMC interface with a maximum of three images at a time which are read for processing and transmission and then replaced with a new set of images. The images are 2-D arrays 512 pixels high and 640 pixels wide, which are read from the SRAM as tiles of 16 x 16 pixels and fed into the lossless compression algorithm. The output of the compression algorithm is a set of 1280 compressed packets obtained from one image which are further processed to handle fragmentation loss and transmission loss by concatenating them to prefixes containing index and length, which finally are stored into the flash in contiguous memory locations with the timestamp specific to every image. When the satellite is over the region of interest and the power budget allows transmission of data, the compressed and processed data is fetched in chunks of 223 bytes and fed into the RS encoding algorithm which spits out a stream of 255 bytes ready for transmission. These byte streams are then handed over to the CC1101 transceiver in pairs which implements packetization as a part of its own transmission protocol and ultimately transmits those packets to be intercepted by the ground station. A reverse engineered algorithm is used to retrieve the original images and further image processing is used to enhance and extract as much information as possible out of them. The orbit propogator is a tool which uses orbital dynamics to predict the location of the stellite in the assumed euclidean space at time t based on the orbital parameters at time t - 1 (t minus one). Like any dynamic system, the orbit propogator accumulates error due to unquantifiable variables and needs calliberation, which is provided by interfacing with the on-board GPS using the UART communication protocol and hence the values of orbit propogator are correctly updated.

Lessons Learnt:

Justification Of A No-OS Model On STM32L4:
The STM32L4 microcontroller runs on 

Future Propects:

History:

Evoluiton:

